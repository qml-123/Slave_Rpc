// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Slave.h"
#include "db/mysql_rsync.h"
#include "db/mysql_client.h"
#include "db/mysql_client_pool.h"
#include "log/elog.h"
#include <iostream>
#include <memory>
#include <map>
#include <unistd.h>
#include <unordered_map>
#include <thrift/protocol/TBinaryProtocol.h>

#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>

#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TNonblockingServerSocket.h>

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using namespace ::rpc::db;
using namespace ::rpc::slave;

std::unordered_map<long long, std::shared_ptr<MysqlClient>> ConId_Client_map;
std::map<long long, std::list<std::shared_ptr<MysqlClient>>::iterator > ConId_Iterator_map;

//slave
class SlaveHandler : virtual public SlaveIf {
public:
    SlaveHandler() {
        // Your initialization goes here
    }
    
    void Rsync(RsyncResponse& _return, const RsyncRequest& RsyncRequest) {
        // Your implementation goes here
        log_i("Rsync init");
        mysql_rsync::set_sql(RsyncRequest.sql_file, RsyncRequest.database);
        _return.message = "success";
        log_i("Rsync success");
    }

    //这里写两阶段提交的准备阶段
    void Try(TryResponse& _return, const TryRequest& tryRequest) {
        // Your implementation goes here
        log_i("Try begin");
        std::shared_ptr<MysqlClient> mysql_client(new MysqlClient);
        _return.check_key = (mysql_client->check_key(tryRequest.key));
        log_i(("Try, key(" + (tryRequest.key) + ") " + (_return.check_key ? "exist" : "not exist")).c_str());
    }
    
    void Get(::rpc::master::GetResponse& _return, const  ::rpc::master::GetRequest& getRequest) {
        // Your implementation goes here
        log_i("Get begin");
        auto mysql_client_iterator = MysqlClientPool::get()->getClient();
        auto mysql_client = *mysql_client_iterator;
        std::string value = mysql_client->get(getRequest.key);
        if (value == "") {
            _return.message = "fail";
        } else {
            _return.message = "success";
            _return.value = value;
        }
        log_i(("Get " + _return.message).c_str());
        std::cout << std::endl;
        MysqlClientPool::get()->delClient(mysql_client_iterator);
        sleep(10);
    }
    
    void Set(::rpc::master::SetResponse& _return, const  ::rpc::master::SetRequest& setRequest) {
        // Your implementation goes here
        log_i(("Set key=" + setRequest.key + " value=" + setRequest.value + " begin").c_str());
    
        log_i(("free_count: " + std::to_string(MysqlClientPool::get()->free_count())).c_str());
        auto mysql_client_iterator = MysqlClientPool::get()->getClient();
        auto mysql_client = *mysql_client_iterator;
        mysql_client->begin();
        _return.connection_id = 1;
        
        if (mysql_client->put(setRequest.key, setRequest.value, setRequest.func_call)) {
            _return.message = "fail";
        } else {
            _return.message = "success";
        }
        
        ConId_Client_map[1] = mysql_client;
        ConId_Iterator_map[1] = mysql_client_iterator;
    
        log_i(("Set key(" + setRequest.key + ") " + _return.message).c_str());
        log_i(("free_count: " + std::to_string(MysqlClientPool::get()->free_count())).c_str());
    
//        sleep(10);
    }
    
    void Del(::rpc::master::DelResponse& _return, const  ::rpc::master::DelRequest& delRequest) {
        // Your implementation goes here
        log_i(("Del key=" + delRequest.key + " begin").c_str());
    
        log_i(("free_count: " + std::to_string(MysqlClientPool::get()->free_count())).c_str());
        auto mysql_client_iterator = MysqlClientPool::get()->getClient();
        auto mysql_client = *mysql_client_iterator;
        mysql_client->begin();
        _return.connection_id = 1;
        if (mysql_client->del(delRequest.key)) {
            _return.message = "fail";
        } else {
            _return.message = "success";
        }
        
        ConId_Client_map[1] = mysql_client;
        ConId_Iterator_map[1] = mysql_client_iterator;
    
        log_i(("Del key(" + delRequest.key + ") " + _return.message).c_str());
    
        log_i(("free_count: " + std::to_string(MysqlClientPool::get()->free_count())).c_str());
    
//        sleep(10);
    }
    
    void Finish(FinishResponse& _return, const FinishRequest& finishRequest) {
        // Your implementation goes here
        log_i("finish begin");
        log_i((finishRequest.call_func + " " + std::to_string(finishRequest.connection_id)).c_str());
        log_i(("free_count: " + std::to_string(MysqlClientPool::get()->free_count())).c_str());
        if (!ConId_Client_map.count(finishRequest.connection_id)) {
            _return.message = "fail";
            log_w(("finish " + _return.message).c_str());
            return;
        }
        
        auto mysql_client_iterator = ConId_Iterator_map[finishRequest.connection_id];
        auto mysql_client = *mysql_client_iterator;
        
        if (mysql_client->exec(finishRequest.call_func)) {
            _return.message = "fail";
        } else {
            _return.message = "success";
        }
        
        ConId_Client_map.erase(finishRequest.connection_id);
        ConId_Iterator_map.erase(finishRequest.connection_id);
    
        log_i(("finish " + _return.message).c_str());
        MysqlClientPool::get()->delClient(mysql_client_iterator);
        log_i(("free_count: " + std::to_string(MysqlClientPool::get()->free_count())).c_str());
    
//        sleep(10);
    }
    
};

int main(int argc, char **argv) {
    //log init
    setbuf(stdout, NULL);
    elog_init();
    elog_set_fmt(ELOG_LVL_ASSERT, ELOG_FMT_LVL | ELOG_FMT_TAG | ELOG_FMT_TIME);
    elog_set_fmt(ELOG_LVL_ERROR, ELOG_FMT_ALL);
    elog_set_fmt(ELOG_LVL_WARN, ELOG_FMT_ALL);
    elog_set_fmt(ELOG_LVL_INFO, ELOG_FMT_ALL);
    elog_set_fmt(ELOG_LVL_DEBUG, ELOG_FMT_ALL & ~ELOG_FMT_FUNC);
    elog_set_fmt(ELOG_LVL_VERBOSE, ELOG_FMT_ALL & ~ELOG_FMT_FUNC);
    elog_start();
    
    int port = 9091;
    ::apache::thrift::stdcxx::shared_ptr<SlaveHandler> handler(new SlaveHandler());
    ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new SlaveProcessor(handler));
    ::apache::thrift::stdcxx::shared_ptr<TNonblockingServerSocket> serverTransport(new TNonblockingServerSocket(port));
    ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
    ::apache::thrift::stdcxx::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);
    ::apache::thrift::stdcxx::shared_ptr<PlatformThreadFactory> threadFactory(new PlatformThreadFactory());
    
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    
    TNonblockingServer server(processor, protocolFactory, serverTransport, threadManager);
    server.setNumIOThreads(5);//设置处理连接请求线程数
    server.serve();
    return 0;
}

